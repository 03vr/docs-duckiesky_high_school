# The Unscented Kalman Filter: Nonlinear State Estimation {#ukf-specifics status=draft}

### Limitations of the Standard (Linear) Kalman Filter

So far, we have discussed the standard Kalman Filter algorithm. However, we have not mentioned its limitations. The standard Kalman Filter assumes that the system is both *linear* and *Gaussian*. In other words, the uncertainties in the motion and measurement models are assumed to be normally distributed about a mean in order to produce optimal estimates, which allows us to represent the state estimate as a Gaussian with mean and variance. For many systems, the Gaussian assumption is a good one. Intuitively, one can imagine that a sensor's noise, for example, varies more or less symmetrically about a true mean value, with larger deviations occurring less frequently.

The greater constraint, however, is the assumption that the system is linear. What we mean by this is that the state transition function and measurement function are linear functions, and as a result, when we pass Gaussian distributions through these functions, the output remains Gaussian or proportional to a Gaussian. An arbitrary nonlinear function, on the other hand, will not output another Gaussian or scaled Gaussian, which is a problem since so much of the Kalman Filter math depends on the state estimate being Gaussian. The Unscented Kalman Filter was expressly designed to robustly handle this issue of nonlinearity.

In this project's z-axis UKF, the functions are linear, so indeed a standard Kalman Filter would suffice. However, for the second UKF that you will be implementing, there are nonlinearities due to the drone's orientation in space. To make the transition easier from the first part to the second part of this project, we are asking you to implement a UKF even for a linear system. The UKF estimates will be the same as a KF; the only downsides might be code complexity and computation time. That said, you will be using a Python library called FilterPy (written by Labbe, author of *Kalman and Bayesian Filters in Python* [](#bib:labbe_kalman)) that handles and hides most of the filtering math anyway.

You might also be wondering what the term "unscented" has to do with a Kalman Filter that applies to nonlinear systems. There is no greater technical meaning to the word; the inventor claims it is an arbitrary choice that resulted from his catching a glimpse of a coworker's deodorant while trying to come up with a name for his filter [](#bib:uhlmann).

### Underlying Principle of the UKF

To handle the nonlinearities, the UKF uses a sampling scheme. An alternative to the UKF known as the Extended Kalman Filter (EKF) uses Jacobians to linearize the nonlinear equations, but the UKF takes a deterministic sampling approach that in many cases results in more accurate estimates and is a simpler algorithm to implement [_TODO: Cite Tellex et al. from the Estimation for Quadrotors paper (should be published on arXiv soon)_].

The UKF uses a function to compute so-called **sigma points**, which are the sample points to pass through the state transition and measurement functions. Each sigma point also has corresponding **weights** for the sample's mean and covariance. The sigma points are generated so that there are $2n+1$ of them, where $n$ is the size of the state vector. Imagine a one-dimensional state vector, for example, which we represent as a single-variable Gaussian. In this instance, $2(1)+1=3$ sigma points are chosen. One of these points is the mean of the Gaussian, and the two other points are symmetric about the mean on either side. The exact distance of these points from the mean sigma point will vary depending on parameters passed into the sigma point function, but we do not expect you to worry about these parameters. The idea, though, is that these $2(1)+1=3$ sigma points and their weights are sufficiently representative of the Gaussian distribution.

The idea, then, is that these points that represent the Gaussian state estimate can be passed through a nonlinear function (i.e., the state transition or measurement functions), which can scatter the points arbitrarily. We then want to recover a Gaussian from these scattered points, and we do so by using the **unscented transform**, which computes a new mean and covariance matrix. To compute the new mean, the unscented transform calculates a weighted sum of each sigma point with its associate sample mean weight.

### UKF in the Prediction Step

The UKF formulates the prior state estimate by specifying a set of sigma points $\boldsymbol{\mathcal{X}}$ according to the current state estimate and then propagating these points through the state transition function to yield a new set of sigma points $\boldsymbol{\mathcal{Y}}$, which are passed through the unscented transform to produce the prior state estimate.

### UKF in the Update Step

For the update step, we pass the prior sigma points $\boldsymbol{\mathcal{Y}}$ through the measurement function to yield a set of measurement sigma points $\boldsymbol{\mathcal{Z}} = h(\boldsymbol{\mathcal{Y}})$. This set of points is then passed through the unscented transform, which computes the mean and covariance of these sample points. The mean is subtracted from the measurement to compute the residual. Labbe chapter 10.5.2 [](#bib:labbe_kalman) goes into more detail about this computation, as well as describing the computation of the Kalman gain specific to the UKF. Once we have a prior state estimate, a residual, and a Kalman gain, we can compute the posterior state estimate as usual with $\mathbf{x} = \mathbf{\bar x} + \mathbf{Ky}$.
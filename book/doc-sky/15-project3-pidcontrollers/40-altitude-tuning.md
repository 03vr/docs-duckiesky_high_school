# Part 3: Altitude Tuning {#pid-assignment status=ready}

In this part, you will be transferring the altitude PID you created in part 1 onto your drone. You will then tune the PID gains on your drone as you did in the simulator.

## Problem 1: Flying with Your Altitude PID!
Now that the planar PIDs are tuned, and you have found a value for `throttle_low.init_i` that allows the drone to take off at a reasonable rate, you will be using your altitude PID to control the height of the drone. To tune your altitude PID, you will first use the Ziegler-Nichols tuning method to generate an initial set of tuning values. You will then fine tune these values similar to how you tuned the drone in simulation.  

 To use your PID, you'll be running <i>student_pid_controller.py</i> instead of <i>pid_controller.py</i>. This will allow your PID to run alongside our planar PIDs, and on top of our throttle low-rate I-term which you found previously. Your PID will be responsible for keeping the drone flying steady vertically.  

**Exercises**  
Change directories to `~/ws/src`. Run `git clone https://github.com/h2r/project3pid-yourGithubName.git`. Then change directories back to `~/ws/` and run `catkin_make --pkg project3pid-yourGitHubName`.

Change directories into `~/ws/src/pidrone_pkg` and modify _pi.screenrc_ to start up with your altitude pid by changing `python pid_controller.py\n` to `rosrun project3pid-yourGitHubName student_pid_controller.py`. Prepare your drone to fly and then navigate to \`4 of the screen. Press ctrl-c to quit student_pid_controller.

In this screen, modify `~/ws/src/project3pid-yourGitHubName/z_pid.yaml` by setting $K$ to 1250 and the rest of the gain constants to 0. Now run `rosrun project3pid-yourGitHubName student_pid_controller.py` to fly with your altitude PID.  

Fly your drone and observe its flight. Tune $K_p$ by slowly increasing its value between flights until you can see the drone moving up and down with uniform oscillations. Each time you will need to quit the controller, edit `~/ws/src/project3pid-yourGitHubName/z_pid.yaml`, and then run `rosrun project3pid-yourGitHubName student_pid_controller.py` again to use the new PID gains.

  1. Record your final $K_p$ value that causes uniform oscillations as $K_u$, the ultimate gain.  
  2. Fly your drone and pause the altitude graph on the web interface when you see two peaks. Find the time difference between these two peaks and record this value as $T_u$, the ultimate period.  
  3. Use your $K_u$ and $T_u$ values to compute $K_p$, $K_i$, and $K_d$. Refer to the equations in the Ziegler-Nichols section in the introduction to this project. Record these values and change <i>z_pid.yaml</i> accordingly.  
  4. Fly your drone with the set of tuning values generated by the Ziegler-Nichols method. Note that the Ziegler-Nichols method should enable safe flight, but will probably not control your drone's altitude very well! Empirically tune the gain constants in <i>z_pid.yaml</i> on your drone as you did in the simulator portion of this project. <sup id="a2">[2](#f2)</sup>  
  5. Report your final tuning values.  

Take a video of your drone flying first using our altitude pid by running <i>pid_controller.py</i> in \`4, then take a video of your tuned pid by running <i>student_pid_controller.py</i> in \`4. See if you can get yours to track the altitude setpoint better than ours! The drone should get to the setpoint quickly and stay there without bouncing up and down. *Submit these videos in Github Classroom as 'original_controller' and 'student_controller'*

## Problem 2: Position Control
As described in the introduction, when switching from velocity control to position control, a cascaded PID controller is used. The position controller forms the outer loop which provides setpoints for the inner loop velocity controller.  

Once you have achieved good trim and can fly steady with velocity control, you can try position control. Try to fly your drone for an entire battery without touching the controls! Do not try this until your I-term preloads have been tuned as described above.  

This [video](https://www.youtube.com/embed/WTohnsKs7dU) demonstrates the drone doing a zero velocity hover and drifting in the scene. Then we turn on position hold (you can tell when it is engaged when the drone's throttle drops) and it holds its position for several minutes.  

Then we turn off the position hold so you can see it drift again, and then turn it on again at the end and land. You can tell when it is turned on because we move the drone back to the center of the flight area before each hold.  

Engage position control in two steps. First you have to tell the drone to “remember” a frame. You can do this using the _r_ key. This will save the frame at the drone’s current location. Next you have to engage or disengage position control. You can engage this mode with the _p_ key, and disengage with _v_ for velocity control. So the procedure is to first save a frame (target location for the position hold) using _r_ and then shortly after (before drifting too much) type _p_.  

Position hold works best over a textured surface with lots of visual contrast. Even when doing position hold, always be ready to kill in case of a mishap. Especially be careful when looking at other windows.  

**Exercises**  
1. Engage position hold using the procedure described above. Observe the drone's behavior. How is it different from velocity mode?  
2. How long are you able to hold position? Ideally you should be able to do this in one spot for an entire battery. If not, try re-tuning your I-term preloads above. If you're flying on the power supply instead of a battery, the drone should stay in place indefinitely, but you can stop it after 5 minutes.  
3. Turn off position hold with _v_ and make sure there is room to fly to the right. Press and hold 'L' and observe the drone's motion, and release 'L' to stop the drone from moving. Explain what happens to the following key terms that causes the drone to move when you press 'L' and stop when you release: setpoint, error, control variable, process variable, proportional term, integral term, derivative term. We are looking only for a higher level description to demonstrate understanding of the PID controllers.  
4. While flying in position control, make sure there is room for the drone to fly to the right and then take note of the desired position in \`4 of the screen. Now press the 'L' key in the user interface and note the new desired x-position of the drone; it should be 0.1m to the right of the drone's last position. Explain what happens to the following key terms of the outer control loop, the position PID, that causes the drone to move and stop 0.1m to the right after you press 'L' in position control: setpoint, error, control variable, process variable, proportional term, integral term, derivative term. We are looking only for a higher level description to demonstrate understanding of cascaded PID controllers.  
5. When the 'L' is first pressed, the derivative term spikes. Briefly explain why the derivative term spikes, and one possible way to prevent this spike.  

Take a one minute video of your drone flying in velocity control, and then engage position control. *Submit this video in Github Classroom as 'postion_control'*  

***Optional Exercises (not graded, but cool to try!)***  
6. Try flying in velocity mode over a blank white poster board (there is one in 121). Be careful! How does the drone's behavior change?  
7. Now try over a uniform textured surface such as the floor in 121. Try a position hold. How well does it work? How long is it able to hold position?  

###### Footnotes
[<b id="f1">1</b>](#a1) It is important to do these tests over a textured surface so that the planar motion of the drone can be properly sensed using the optical flow vectors of the camera (more on this in another section)

[<b id="f2">2</b>](#a2) Use the graph on the web interface to observe the drone's behavior as it oscillates around the 0.3m setpoint the drone's ability to hover at the setpoint. When observing the drone itself, try to get eye-level with the drone to just focus on the the altitude and ignore the planar motion; it is easier to focus on one axis at a time when tuning the PIDs. The planar axes can be re-tuned after you tune your altitude pid if need be.

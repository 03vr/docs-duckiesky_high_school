# Part 3: Altitude Tuning {#pid-assignment status=ready}

In this part, you will be transferring the altitude PID you created in part 1 onto your drone. You will then tune the PID gains on your drone as you did in the simulator.

## Problem 1: Flying with Your Altitude PID!
Now that the planar PIDs are tuned, and you have found a value for `throttle_low.init_i` that allows the drone to take off at a reasonable rate, you will be using your altitude PID to control the height of the drone. To tune your altitude PID, you will first use the Ziegler-Nichols tuning method to generate an initial set of tuning parameters. You will then fine tune these parameters similar to how you tuned the drone in simulation.

 To use your PID, you'll be running <i>student_pid_controller.py</i> instead of <i>pid_controller.py</i>. This will allow your PID to run alongside our planar PIDs, and on top of our throttle low-rate I-term which you found previously. Your PID will be responsible for keeping the drone flying steady vertically.

**Setup**
Change directories to `~/ws/src`. Run `git clone https://github.com/h2r/project3pid-yourGithubName.git`. Then change directories back to `~/ws/` and run `catkin_make --pkg project3pid-yourGitHubName`.

Change directories into `~/ws/src/pidrone_pkg` and modify _pi.screenrc_ to start up with your altitude pid by changing `python pid_controller.py\n` to `rosrun project3pid-yourGitHubName student_pid_controller.py\n`. Prepare your drone to fly and then navigate to \`4 of the screen. Press ctrl-c to quit student_pid_controller.

In this screen (\`4), modify `~/ws/src/project3pid-yourGitHubName/z_pid.yaml` by setting $K$ to 1250 and the rest of the gain constants to 0. Now run `rosrun project3pid-yourGitHubName student_pid_controller.py` to fly with your altitude PID.

**Exercises**

Fly your drone and observe its flight. Tune $K_p$ by slowly increasing its value between flights until you can see the drone moving up and down with uniform oscillations. Each time you will need to quit the controller, edit `~/ws/src/project3pid-yourGitHubName/z_pid.yaml`, and then run `rosrun project3pid-yourGitHubName student_pid_controller.py` again to use the new PID gains.

  1. Record your final $K_p$ value that causes uniform oscillations as $K_u$, the ultimate gain.
  2. Fly your drone and pause the altitude graph on the web interface when you see two peaks. Find the time difference between these two peaks and record this value as $T_u$, the ultimate period.
  3. Use your $K_u$ and $T_u$ values to compute $K_p$, $K_i$, and $K_d$. Refer to the equations in the Ziegler-Nichols section in the introduction to this project. Record these values and change <i>z_pid.yaml</i> accordingly.
  4. Fly your drone with the set of tuning values generated by the Ziegler-Nichols method. Note that the Ziegler-Nichols method should enable safe flight, but will probably not control your drone's altitude very well! Empirically tune the gain constants in <i>z_pid.yaml</i> on your drone as you did in the simulator portion of this project. <sup id="a2">[2](#f2)</sup> Record your final tuning values.

Take a video of your drone flying first using our altitude pid by running <i>pid_controller.py</i> in \`4, then take a video of your tuned pid by running <i>student_pid_controller.py</i> in \`4. See if you can get yours to track the altitude setpoint better than ours! The drone should get to the setpoint quickly and stay there without bouncing up and down. *Submit these videos in Github Classroom as 'original_controller' and 'student_controller'*

###### Footnotes
[<b id="f1">1</b>](#a1) It is important to do these tests over a textured surface so that the planar motion of the drone can be properly sensed using the optical flow vectors of the camera (more on this in another section)

[<b id="f2">2</b>](#a2) Use the graph on the web interface to observe the drone's behavior as it oscillates around the 0.3m setpoint the drone's ability to hover at the setpoint. When observing the drone itself, try to get eye-level with the drone to just focus on the the altitude and ignore the planar motion; it is easier to focus on one axis at a time when tuning the PIDs. The planar axes can be re-tuned after you tune your altitude pid if need be.
